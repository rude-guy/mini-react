(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('scheduler')) :
  typeof define === 'function' && define.amd ? define(['react', 'scheduler'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactNoopRenderer = factory(global.React, global.scheduler));
})(this, (function (React, scheduler) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;
  const Fragment = 7;

  const NoFlags = 0b0000000;
  const Placement = 0b0000001;
  const Update = 0b0000010;
  const ChildDeletion = 0b0000100;
  const PassiveEffect = 0b0001000;
  const MutationMask = Placement | Update | ChildDeletion;
  const PassiveMask = PassiveEffect | ChildDeletion;

  const SyncLane = 0b0001;
  const NoLane = 0b0000;
  const NoLanes = 0b0000;
  function mergeLanes(a, b) {
      return a | b;
  }
  function requestUpdateLane() {
      return SyncLane; // 同步更新
  }
  function getHighestPriorityLane(lanes) {
      return lanes & -lanes;
  }
  function markRootFinished(root, lane) {
      root.pendingLanes &= ~lane;
  }

  class FiberNode {
      type;
      tag;
      key;
      stateNode;
      ref;
      return;
      sibling;
      child;
      index;
      pendingProps;
      memoizedProps;
      memoizedState;
      updateQueue;
      alternate;
      flags;
      subTreeFlags;
      deletions;
      constructor(tag, pendingProps, key) {
          // 实例
          this.tag = tag;
          this.key = key || null;
          this.stateNode = null;
          this.type = null;
          // 构成树状结构
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          // 作为工作单元
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.alternate = null;
          // 副作用
          this.flags = NoFlags;
          this.subTreeFlags = NoFlags;
          this.deletions = null;
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      pendingLanes;
      finishedLane;
      pendingPassiveEffect;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
          this.pendingLanes = NoLanes;
          this.finishedLane = NoLane;
          this.pendingPassiveEffect = {
              unmount: [],
              update: [],
          };
      }
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate;
      // mount
      if (wip === null) {
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.stateNode = current.stateNode;
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subTreeFlags = NoFlags;
          wip.deletions = null;
      }
      wip.type = current.type;
      wip.updateQueue = current.updateQueue;
      wip.child = current.child;
      wip.memoizedProps = current.memoizedProps;
      wip.memoizedState = current.memoizedState;
      return wip;
  };
  const createFiberFromElement = (element) => {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && true) {
          console.warn('未定义的type类型', type);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  };
  const createFiberFromFragment = (elements, key) => {
      const fiber = new FiberNode(Fragment, elements, key);
      return fiber;
  };

  const createUpdate = (action, lane) => {
      return {
          action,
          lane,
          next: null,
      };
  };
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null,
          },
          dispatch: null,
      };
  };
  // 追加update
  const enqueueUpdate = (updateQueue, update) => {
      const pending = updateQueue.shared.pending;
      if (pending === null) {
          // pending = a -> a
          update.next = update;
      }
      else {
          // pending = b -> a -> b
          // pending = c -> a -> b -> c
          update.next = pending.next;
          pending.next = update;
      }
      updateQueue.shared.pending = update;
  };
  // 消费update
  const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
      const result = {
          memoizedState: baseState,
      };
      if (pendingUpdate !== null) {
          // 第一个update
          const first = pendingUpdate.next;
          let pending = pendingUpdate.next;
          do {
              const updateLane = pending.lane;
              if (updateLane === renderLane) {
                  const action = pendingUpdate.action;
                  // baseState 1 -> update (x) => 2x -> memoizedState 2
                  if (action instanceof Function) {
                      baseState = action(baseState);
                  }
                  else {
                      // baseState 1 -> update 2 -> memoizedState 2
                      baseState = action;
                  }
              }
              else {
                  {
                      console.error('不应该进入updateLane !== renderLane');
                  }
              }
              pending = pending.next;
          } while (pending !== first);
      }
      result.memoizedState = baseState;
      return result;
  };

  let insertCounter = 0;
  const createInstance = (type, props) => {
      const instance = {
          id: insertCounter++,
          type,
          children: [],
          parent: -1,
          props,
      };
      return instance;
  };
  const appendInitialChild = (parent, child) => {
      const preParentId = child.parent;
      const parentId = 'rootID' in parent ? parent.rootID : parent.id;
      if (preParentId !== -1 && preParentId !== parentId) {
          throw Error('child already has parent');
      }
      child.parent = parentId;
      parent.children.push(child);
  };
  const createTextInstance = (content) => {
      const textInstance = {
          text: content,
          id: insertCounter++,
          parent: -1,
      };
      return textInstance;
  };
  const appendChildToContainer = (parent, child) => {
      const preParentId = child.parent;
      if (preParentId !== -1 && preParentId !== parent.rootID) {
          throw Error('child already has parent');
      }
      child.parent = parent.rootID;
      parent.children.push(child);
  };
  const commitUpdate = (fiber) => {
      switch (fiber.tag) {
          case HostText:
              const text = fiber.memoizedProps.content;
              return commitTextUpdate(fiber.stateNode, text);
          default:
              {
                  console.warn('未实现的更新类型', fiber);
              }
              break;
      }
  };
  function commitTextUpdate(textInstance, content) {
      textInstance.text = content;
  }
  function removeChild(child, container) {
      const index = container.children.indexOf(child);
      if (index === -1) {
          throw Error('container not contain child');
      }
      container.children.splice(index, 1);
  }
  function insertChildToContainer(child, container, before) {
      const beforeIndex = container.children.indexOf(before);
      if (beforeIndex === -1) {
          throw Error('before is not child of container');
      }
      const childIndex = container.children.indexOf(child);
      if (childIndex !== -1) {
          container.children.splice(childIndex, 1); // 删除已存在的子节点
      }
      container.children.splice(beforeIndex, 0, child);
  }
  const scheduleMicroTask = typeof queueMicrotask === 'function'
      ? queueMicrotask
      : typeof Promise === 'function'
          ? (callback) => Promise.resolve(null).then(callback)
          : setTimeout;

  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7;
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for('react.fragment')
      : 0xeacb;

  function ChildReconciler(shouldTrackEffect) {
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackEffect) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackEffect) {
              return;
          }
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      // 创建子fiber
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const key = element.key;
          while (currentFiber !== null) {
              /** update */
              // key相同
              if (currentFiber.key === key) {
                  if (element.$$typeof === REACT_ELEMENT_TYPE) {
                      // type 相同
                      if (element.type === currentFiber.type) {
                          let props = element.props;
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              props = element.props.children;
                          }
                          const existing = useFiber(currentFiber, props);
                          existing.return = returnFiber;
                          // 当前节点可服用，剩下节点删除
                          deleteRemainingChildren(returnFiber, currentFiber.sibling);
                          return existing;
                      }
                      // type 不同
                      deleteRemainingChildren(returnFiber, currentFiber);
                      break;
                  }
                  else {
                      {
                          console.warn('未实现的ReactElement类型', element);
                          break;
                      }
                  }
              }
              else {
                  // key 不同 删除旧节点
                  deleteChild(returnFiber, currentFiber);
                  currentFiber = currentFiber.sibling;
              }
          }
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      // 创建文本子fiber
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          while (currentFiber !== null) {
              /**  update */
              // type 相同
              if (currentFiber.tag === HostText) {
                  const existing = useFiber(currentFiber, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, currentFiber.sibling);
                  return existing;
              }
              // type 不同
              deleteChild(returnFiber, currentFiber);
              currentFiber = currentFiber.sibling;
          }
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      // 插入节点操作
      function placeSingleChild(fiber) {
          if (shouldTrackEffect && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      // 多节点情况
      function reconcileChildArray(returnFiber, currentFirstChild, newChild) {
          // 最后一个可复用fiber在current中的index
          let lastPlacedIndex = 0;
          // 创建的最后一个fiber
          let lastNewFiber = null;
          // 创建的第一个fiber
          let firstNewFiber = null;
          // 1. 将current保存在map中
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index;
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          for (let i = 0; i < newChild.length; i++) {
              // 2. 遍历newChild，寻找是否可复用
              const child = newChild[i];
              const newFiber = updateFromMap(returnFiber, existingChildren, i, child);
              if (newFiber === null) {
                  continue;
              }
              // 3. 标记移动还是插入
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber === null) {
                  lastNewFiber = newFiber;
                  firstNewFiber = newFiber;
              }
              else {
                  lastNewFiber.sibling = newFiber;
                  lastNewFiber = lastNewFiber.sibling;
              }
              if (!shouldTrackEffect) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // 移动
                      newFiber.flags |= Placement;
                      continue;
                  }
                  else {
                      // 不移动
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // mount
                  newFiber.flags |= Placement;
              }
          }
          // 4. 将Map中剩下的标记为删除
          existingChildren.forEach((child) => {
              deleteChild(returnFiber, child);
          });
          return firstNewFiber;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          const keyToUse = element.key !== null ? element.key : index;
          const before = existingChildren.get(keyToUse);
          // HostText
          if (typeof element === 'string' || typeof element === 'number') {
              if (before) {
                  if (before.tag === HostText) {
                      existingChildren.delete(keyToUse);
                      return useFiber(before, { content: `${element}` });
                  }
              }
              return new FiberNode(HostText, { content: `${element}` }, null);
          }
          // ReactElement
          if (typeof element === 'object' && element !== null) {
              if (Array.isArray(element)) {
                  return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
              }
              switch (element.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      if (element.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
                      }
                      if (before) {
                          if (before.type === element.type) {
                              existingChildren.delete(keyToUse);
                              return useFiber(before, element.props);
                          }
                      }
                      return createFiberFromElement(element);
              }
          }
          return null;
      }
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断Fragment
          const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
              newChild !== null &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
          }
          // 判断当前的 fiber 类型
          if (typeof newChild === 'object' && newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn('未实现的 reconcile 类型', newChild);
                      }
                      break;
              }
              // 多节点情况
              if (Array.isArray(newChild)) {
                  return reconcileChildArray(returnFiber, currentFiber, newChild);
              }
          }
          // HostText
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          // 兜底删除
          if (currentFiber !== null) {
              deleteRemainingChildren(returnFiber, currentFiber);
          }
          {
              console.warn('未实现的 reconcile 类型', newChild);
          }
          return null;
      };
  }
  function useFiber(fiber, pendingProps) {
      const clone = createWorkInProgress(fiber, pendingProps);
      clone.index = 0;
      clone.sibling = null;
      return clone;
  }
  function updateFragment$1(returnFiber, current, element, key, existingChildren) {
      let fiber;
      if (!current || current.tag !== Fragment) {
          fiber = createFiberFromFragment(element, key);
      }
      else {
          existingChildren.delete(key);
          fiber = useFiber(current, element);
      }
      fiber.return = returnFiber;
      return fiber;
  }
  // 追踪副作用 update
  const reconcileChildFibers = ChildReconciler(true);
  // 不追踪副作用 mount
  const mountChildFibers = ChildReconciler(false);

  const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  const Passive = 0b00010;
  const HookHasEffect = 0b00001;

  let currentlyRenderingFiber = null;
  let workInProgressHook = null;
  let currentHook = null;
  let renderLane = NoLane;
  const { currentDispatcher } = internals;
  function renderWithHooks(wip, lane) {
      // render 之前
      currentlyRenderingFiber = wip;
      renderLane = lane;
      // 重置 memoizedState
      wip.memoizedState = null;
      // 重置 effect 链表
      wip.updateQueue = null;
      const current = wip.alternate;
      if (current !== null) {
          // update
          currentDispatcher.current = hooksDispatcherOnUpdate;
      }
      else {
          // mount
          currentDispatcher.current = hooksDispatcherOnMount;
      }
      const Component = wip.type;
      const props = wip.pendingProps;
      const children = Component(props);
      // render之后
      currentlyRenderingFiber = null;
      workInProgressHook = null;
      currentHook = null;
      renderLane = NoLane;
      return children;
  }
  const hooksDispatcherOnMount = {
      useState: mountState,
      useEffect: mountEffect,
  };
  const hooksDispatcherOnUpdate = {
      useState: updateState,
      useEffect: updateEffect,
  };
  function updateEffect(create, deps) {
      const hook = updateWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      let destroy;
      if (currentHook !== null) {
          const prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
              // 浅比较依赖
              const prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
                  return;
              }
              else {
                  currentlyRenderingFiber.flags |= PassiveEffect;
                  hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
              }
          }
      }
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
      if (prevDeps === null || nextDeps === null) {
          return false;
      }
      for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (Object.is(nextDeps[i], prevDeps[i])) {
              continue;
          }
          return false;
      }
      return true;
  }
  function mountEffect(create, deps) {
      const hook = mountWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      currentlyRenderingFiber.flags |= PassiveEffect;
      hook.memoizedState = pushEffect(Passive | HookHasEffect, create, undefined, nextDeps);
  }
  function pushEffect(hookFlags, create, destroy, deps) {
      const effect = {
          tag: hookFlags,
          create,
          destroy,
          deps,
          next: null,
      };
      const fiber = currentlyRenderingFiber;
      const updateQueue = fiber.updateQueue;
      if (updateQueue === null) {
          const updateQueue = createFCUpdateQueue();
          fiber.updateQueue = updateQueue;
          effect.next = effect;
          updateQueue.lastEffect = effect;
      }
      else {
          const lastEffect = updateQueue.lastEffect;
          if (lastEffect === null) {
              effect.next = effect;
              updateQueue.lastEffect = effect;
          }
          else {
              const firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              updateQueue.lastEffect = effect;
          }
      }
      return effect;
  }
  function createFCUpdateQueue() {
      const updateQueue = createUpdateQueue();
      updateQueue.lastEffect = null;
      return updateQueue;
  }
  function updateState() {
      // 找到当前useState对应的hook的数据
      const hook = updateWorkInProgressHook();
      // 实现update计算新state
      const queue = hook.updateQueue;
      const pending = queue.shared.pending;
      queue.shared.pending = null;
      if (pending !== null) {
          const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
          hook.memoizedState = memoizedState;
      }
      return [hook.memoizedState, queue.dispatch];
  }
  function updateWorkInProgressHook() {
      // TODO: render 阶段触发的更新
      let nextCurrentHook = null;
      if (currentHook === null) {
          // 这是FC，在update时第一个hook
          const current = currentlyRenderingFiber?.alternate;
          if (current !== null) {
              nextCurrentHook = current?.memoizedState;
          }
          else {
              // mount
              nextCurrentHook = null;
          }
      }
      else {
          // 这个FC 后续的hook
          nextCurrentHook = currentHook.next;
      }
      // 当hooks在条件判断中使用
      if (nextCurrentHook === null) {
          // mount u1 u2 u3
          // update u1 u2 u3 u4
          throw new Error(`组件 ${currentlyRenderingFiber?.type.name} 本次执行时的Hook比上次执行时多`);
      }
      currentHook = nextCurrentHook;
      const newHooks = {
          memoizedState: currentHook.memoizedState,
          updateQueue: currentHook.updateQueue,
          next: null,
      };
      if (workInProgressHook === null) {
          // mount 并且为第一个hook
          if (currentlyRenderingFiber === null) {
              throw new Error('请在函数组件中调用hook');
          }
          else {
              workInProgressHook = newHooks;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
      }
      else {
          // mount 并且不是第一个hook
          workInProgressHook.next = newHooks;
          workInProgressHook = newHooks;
      }
      return workInProgressHook;
  }
  function mountState(initialState) {
      // 找到当前useState对应的hook的数据
      const hook = mountWorkInProgressHook();
      let memoizedState;
      if (initialState instanceof Function) {
          memoizedState = initialState();
      }
      else {
          memoizedState = initialState;
      }
      const updateQueue = createUpdateQueue();
      hook.updateQueue = updateQueue;
      hook.memoizedState = memoizedState;
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, updateQueue);
      updateQueue.dispatch = dispatch;
      return [memoizedState, dispatch];
  }
  function dispatchSetState(fiber, updateQueue, action) {
      const lane = requestUpdateLane();
      const update = createUpdate(action, lane);
      enqueueUpdate(updateQueue, update);
      scheduleUpdateOnFiber(fiber, lane);
  }
  function mountWorkInProgressHook() {
      const hook = {
          memoizedState: null,
          updateQueue: null,
          next: null,
      };
      if (workInProgressHook === null) {
          // mount 并且为第一个hook
          if (currentlyRenderingFiber === null) {
              throw new Error('请在函数组件中调用hook');
          }
          else {
              workInProgressHook = hook;
              currentlyRenderingFiber.memoizedState = workInProgressHook;
          }
      }
      else {
          // mount 并且不是第一个hook
          workInProgressHook.next = hook;
          workInProgressHook = hook;
      }
      return workInProgressHook;
  }

  const beginWork = (wip, renderLane) => {
      // 比较,返回子 fiberNode
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip, renderLane);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(wip, renderLane);
          case Fragment:
              return updateFragment(wip);
          default:
              {
                  console.warn('未实现的 beginWork 类型', wip.tag);
              }
              break;
      }
      return null;
  };
  function updateFragment(wip) {
      const nextChildren = wip.pendingProps;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateFunctionComponent(wip, renderLane) {
      const nextChildren = renderWithHooks(wip, renderLane);
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostRoot(wip, renderLane) {
      const baseState = wip.memoizedState;
      const updateQueue = wip.updateQueue;
      const pending = updateQueue.shared.pending;
      updateQueue.shared.pending = null;
      const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
      wip.memoizedState = memoizedState;
      const nextChildren = wip.memoizedState;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostComponent(wip) {
      const pendingProps = wip.pendingProps;
      const nextChildren = pendingProps.children;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function reconcileChildren(wip, children) {
      const current = wip.alternate;
      if (current !== null) {
          // update
          wip.child = reconcileChildFibers(wip, current.child, children);
      }
      else {
          // mount
          wip.child = mountChildFibers(wip, null, children);
      }
  }

  let nextEffect;
  const commitMutationEffect = (finishedWork, root) => {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          // 向下遍历
          const child = nextEffect.child;
          // 子节点 subTreeFlags不存在或者子节点不存在 不需要进行更新操作
          if ((nextEffect.subTreeFlags & (MutationMask | PassiveMask)) !== NoFlags &&
              child !== null) {
              nextEffect = child;
          }
          else {
              // 向上遍历
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect, root);
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedWork, root) => {
      // flags Placement
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          finishedWork.flags &= ~Placement;
      }
      // flags Update
      if ((flags & Update) !== NoFlags) {
          commitUpdate(finishedWork);
          finishedWork.flags &= ~Update;
      }
      // flags ChildDeletion
      if ((flags & ChildDeletion) !== NoFlags) {
          const deletions = finishedWork.deletions;
          if (deletions !== null) {
              deletions.forEach((childToDelete) => {
                  commitDeletion(childToDelete, root);
              });
          }
          finishedWork.flags &= ~ChildDeletion;
      }
      // fiber PassiveEffect
      if ((flags & PassiveEffect) !== NoFlags) {
          // 收集回调
          commitPassiveEffect(finishedWork, root, 'update');
          finishedWork.flags &= ~PassiveEffect;
      }
  };
  function commitPassiveEffect(fiber, root, type) {
      if (fiber.tag !== FunctionComponent ||
          (type === 'update' && (fiber.flags & PassiveEffect) === NoFlags)) {
          return;
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue !== null) {
          if (updateQueue.lastEffect === null && true) {
              console.warn('当FC组件存在useEffect时，updateQueue.lastEffect不能为null');
          }
          root.pendingPassiveEffect[type].push(updateQueue.lastEffect);
      }
  }
  function commitHookEffectList(flags, lastEffect, callback) {
      let effect = lastEffect.next;
      do {
          if ((effect.tag & flags) === flags) {
              callback(effect);
          }
          effect = effect.next;
      } while (effect !== lastEffect.next);
  }
  function commitHookEffectListUnmount(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
          effect.tag &= ~HookHasEffect;
      });
  }
  function commitHookEffectListDestroy(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
      });
  }
  function commitHookEffectListCreate(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const create = effect.create;
          if (typeof create === 'function') {
              effect.destroy = create();
          }
      });
  }
  function recordHostChildrenToDelete(childToDelete, unmountFiber) {
      // 1. 找到第一个 root host 节点
      const lastOne = childToDelete[childToDelete.length - 1];
      if (!lastOne) {
          childToDelete.push(unmountFiber);
      }
      else {
          let node = lastOne.sibling;
          // 2. 没找到一个 host 节点，判断下这个节点是不是 1 找到那个节点的兄弟节点
          while (node !== null) {
              if (node === unmountFiber) {
                  childToDelete.push(unmountFiber);
                  break;
              }
              node = node.sibling;
          }
      }
  }
  function commitDeletion(childToDelete, root) {
      const rootChildrenToDelete = [];
      // 递归子树
      commitNestedComponent(childToDelete, (unmountFiber) => {
          switch (unmountFiber.tag) {
              case HostComponent:
                  // TODO: 解绑ref
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case HostText:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case FunctionComponent:
                  // TODO: 解绑ref
                  commitPassiveEffect(unmountFiber, root, 'unmount');
                  break;
              default:
                  {
                      console.warn('未处理的unmount类型', unmountFiber);
                  }
          }
      });
      if (rootChildrenToDelete.length) {
          const hostParent = getHostParent(childToDelete);
          if (hostParent !== null) {
              rootChildrenToDelete.forEach((node) => removeChild(node.stateNode, hostParent));
          }
      }
      childToDelete.return = null;
      childToDelete.child = null;
  }
  function commitNestedComponent(root, onCommitUnmount) {
      let node = root;
      while (true) {
          onCommitUnmount(node);
          if (node.child !== null) {
              // 向下遍历
              node.child.return = node;
              node = node.child;
              continue;
          }
          // 终止条件
          if (node === root) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === root) {
                  return;
              }
              // 向上归
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  const commitPlacement = (finishedWork) => {
      {
          console.warn('执行Placement操作', finishedWork);
      }
      // parent DOM
      const hostParent = getHostParent(finishedWork);
      // host sibling
      const hostSibling = getHostSibling(finishedWork);
      if (hostParent) {
          // finishedWork -> DOM
          insertOrAppendPlacemenNodeIntoContainer(finishedWork, hostParent, hostSibling);
      }
  };
  function getHostSibling(fiber) {
      let node = fiber;
      findSibling: while (true) {
          // HostComponent和HostRoot可以作为节点挂载的父元素调用append
          while (node.sibling === null) {
              const parent = node.return;
              if (parent === null ||
                  parent.tag === HostComponent ||
                  parent.tag === HostRoot) {
                  return null;
              }
              node = parent;
          }
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostComponent && node.tag !== HostText) {
              if ((node.flags & Placement) !== NoFlags) {
                  // 向下遍历，node flags必须为稳定的节点
                  continue findSibling;
              }
              if (node.child === null) {
                  continue findSibling;
              }
              else {
                  node.child.return = node;
                  node = node.child;
              }
          }
          if ((node.flags & Placement) === NoFlags) {
              return node.stateNode;
          }
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent !== null) {
          const parentTag = parent.tag;
          // 只存在 HostComponent HostRoot
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn('未找到HostParent');
      }
      return null;
  }
  function insertOrAppendPlacemenNodeIntoContainer(finishedWork, hostParent, before) {
      // fiber Host
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          if (before) {
              insertChildToContainer(finishedWork.stateNode, hostParent, before);
          }
          else {
              appendChildToContainer(hostParent, finishedWork.stateNode);
          }
          return;
      }
      const child = finishedWork.child;
      if (child !== null) {
          insertOrAppendPlacemenNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling !== null) {
              insertOrAppendPlacemenNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }

  function markUpdate(fiber) {
      fiber.flags |= Update;
  }
  const completeWork = (wip) => {
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) {
                  // TODO: update
                  // props 是否变化
                  markUpdate(wip);
              }
              else {
                  // mount
                  // 1. 构建DOM
                  const instance = createInstance(wip.type, newProps);
                  // 2. 将DOM树插入到DOM中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostText:
              if (current !== null && wip.stateNode) {
                  // update
                  const oldText = current.memoizedProps.content;
                  const newText = newProps.content;
                  if (oldText !== newText) {
                      markUpdate(wip);
                  }
              }
              else {
                  // mount
                  // 1. 构建DOM
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case FunctionComponent:
          case HostRoot:
          case Fragment:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn('未处理的completeWork类型', wip);
              }
              return null;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          // 当前节点
          if (node?.tag === HostComponent || node?.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
          }
          // 判断子节点
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          // 判断兄弟节点
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  // 子节点和兄弟节点冒泡到当前节点
  function bubbleProperties(wip) {
      let subTreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subTreeFlags |= child.subTreeFlags;
          subTreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subTreeFlags |= subTreeFlags;
  }

  let syncQueue = null;
  let isFlushingSyncQueue = false;
  function scheduleSyncCallback(callback) {
      if (syncQueue === null) {
          syncQueue = [callback];
      }
      else {
          syncQueue.push(callback);
      }
  }
  function flushSyncCallbacks() {
      if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          try {
              syncQueue.forEach((callback) => callback());
          }
          catch (e) {
              console.error('flushSyncCallbacks error:', e);
          }
          finally {
              isFlushingSyncQueue = false;
              syncQueue = null; // 清空队列
          }
      }
  }

  let workInProgress = null;
  let wipRootRenderLane = NoLane;
  let rootDoesHasPassiveEffects = false;
  function prepareFreshStack(root, lane) {
      workInProgress = createWorkInProgress(root.current, {});
      wipRootRenderLane = lane;
  }
  function scheduleUpdateOnFiber(fiber, lane) {
      // TODO:调度更新
      // fiberRootNode
      const root = markUpdateFromFiberToRoot(fiber);
      markRootUpdated(root, lane);
      ensureRootIsScheduled(root);
  }
  function ensureRootIsScheduled(root) {
      const updateLane = getHighestPriorityLane(root.pendingLanes);
      if (updateLane === NoLane) {
          return;
      }
      if (updateLane === SyncLane) {
          // 同步优先级 微任务调度
          {
              console.log('同步优先级 微任务调度优先：', updateLane);
          }
          scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
          scheduleMicroTask(flushSyncCallbacks);
      }
  }
  function markRootUpdated(root, lane) {
      root.pendingLanes = mergeLanes(root.pendingLanes, lane);
  }
  // 向上遍历找到根节点
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = fiber.return;
      while (parent !== null) {
          node = parent;
          parent = parent.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  function performSyncWorkOnRoot(root, lane) {
      const nextLane = getHighestPriorityLane(root.pendingLanes);
      if (nextLane !== SyncLane) {
          // 其他比SyncLane优先级低
          // NoLane
          ensureRootIsScheduled(root);
          return;
      }
      {
          console.warn('render阶段开始');
      }
      // 初始化
      prepareFreshStack(root, lane);
      do {
          try {
              workLoop();
              break;
          }
          catch (e) {
              {
                  console.warn('workLoop发生错误中断', e);
              }
              workInProgress = null;
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      root.finishedLane = lane;
      wipRootRenderLane = NoLane;
      // wip fiberNode树中的flags
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.warn('commit阶段', finishedWork);
      }
      const lane = root.finishedLane;
      if (lane === NoLane && true) {
          console.warn('commit阶段finishedLane不应该为NoLane', finishedWork);
      }
      /// 重置
      root.finishedWork = null;
      root.finishedLane = NoLane;
      markRootFinished(root, lane);
      if ((finishedWork.flags & PassiveMask) !== NoFlags ||
          (finishedWork.subTreeFlags & PassiveMask) !== NoFlags) {
          if (!rootDoesHasPassiveEffects) {
              rootDoesHasPassiveEffects = true;
              // 调度副作用
              scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, () => {
                  // 执行副作用
                  flushPassiveEffects(root.pendingPassiveEffect);
                  return;
              });
          }
      }
      /** 判断3个子阶段是否存在需要执行的操作 */
      // root flags | root subTreeFlags
      const subTreeHasEffect = (finishedWork.subTreeFlags & MutationMask) !== NoFlags;
      const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subTreeHasEffect || rootHasEffect) {
          // beforeMutation
          // mutation
          // layout
          root.current = finishedWork;
          commitMutationEffect(finishedWork, root);
      }
      else {
          root.current = finishedWork;
      }
      rootDoesHasPassiveEffects = false;
      ensureRootIsScheduled(root);
  }
  function flushPassiveEffects(pendingPassiveEffect) {
      pendingPassiveEffect.unmount.forEach((effect) => {
          commitHookEffectListUnmount(Passive, effect);
      });
      pendingPassiveEffect.unmount = [];
      pendingPassiveEffect.update.forEach((effect) => {
          commitHookEffectListDestroy(Passive | HookHasEffect, effect);
      });
      pendingPassiveEffect.update.forEach((effect) => {
          commitHookEffectListCreate(Passive | HookHasEffect, effect);
      });
      pendingPassiveEffect.update = [];
      flushSyncCallbacks();
  }
  function workLoop() {
      while (workInProgress !== null) {
          // 执行工作
          perFromUnitOfWork(workInProgress);
      }
  }
  // 执行工作单元 -> 递
  function perFromUnitOfWork(fiber) {
      const next = beginWork(fiber, wipRootRenderLane);
      // 执行完后，将pendingProps -> memoizedProps
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber);
      }
      else {
          workInProgress = next;
      }
  }
  // 完成工作单元 -> 归
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node);
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  const createContainer = (container) => {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  };
  const updateContainer = (element, root) => {
      const hostRootFiber = root.current;
      const lane = requestUpdateLane();
      const update = createUpdate(element, lane);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber, lane);
      return element;
  };

  let idCounter = 0;
  function createRoot() {
      const container = {
          rootID: idCounter++,
          children: [],
      };
      // @ts-ignore
      const root = createContainer(container);
      function getChildren(parent) {
          if (parent) {
              return parent.children;
          }
          return null;
      }
      function getChildrenAsJsx(root) {
          const children = childToJsx(root.children);
          if (Array.isArray(children)) {
              return {
                  $$typeof: REACT_FRAGMENT_TYPE,
                  type: REACT_FRAGMENT_TYPE,
                  key: null,
                  ref: null,
                  props: { children },
                  __mark_ref: 'mark',
              };
          }
          return children;
      }
      function childToJsx(child) {
          if (typeof child === 'string' || typeof child === 'number') {
              return child;
          }
          if (Array.isArray(child)) {
              if (child.length === 0) {
                  return null;
              }
              if (child.length === 1) {
                  return childToJsx(child[0]);
              }
              const children = child.map(childToJsx);
              if (children.every((child) => typeof child === 'string' || typeof child === 'number')) {
                  return children.join('');
              }
              return children;
          }
          // Instance
          if (Array.isArray(child.children)) {
              const instance = child;
              const children = childToJsx(instance.children);
              const props = instance.props;
              if (children !== null) {
                  props.children = children;
              }
              return {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: instance.type,
                  key: null,
                  ref: null,
                  props,
                  __mark_ref: 'mark',
              };
          }
          // textInstance
          return child.text;
      }
      return {
          render(element) {
              return updateContainer(element, root);
          },
          getChildren() {
              return getChildren(container);
          },
          getChildrenAsJsx() {
              return getChildrenAsJsx(container);
          },
      };
  }

  var ReactNoopRenderer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactNoopRenderer;

}));
